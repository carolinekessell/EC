<html>

<head>


<button type="button" id="myPuck_connect" > Connect Puck via Bluetooth </button>

<button type="button" id="myrecord_start" > Start New Recording </button>

<button type="button" id="my_Savedata" > Save Date as CSV - File </button>


<script src="https://www.puck-js.com/puck.js"></script>

<script src="https://code.jquery.com/jquery-1.9.1.min.js"></script>
 
<script src="https://code.jquery.com/jquery-1.9.1.min.js"></script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dygraph/2.1.0/dygraph.js"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dygraph/2.1.0/dygraph.css" />
 
 <script type="text/javascript"> 
package uk.me.berndporr.iirj;

import org.apache.commons.math3.complex.Complex;
import org.apache.commons.math3.complex.ComplexUtils;

/**
 *         User facing class which contains all the methods the user uses
 *         to create Butterworth filters. This done in this way:
 *         Butterworth butterworth = new Butterworth(); 
 *         Then call one of the methods below to create
 *         low-,high-,band-, or stopband filters. For example:
 *         butterworth.bandPass(2,250,50,5);
 */
public class Butterworth extends Cascade {

	class AnalogLowPass extends LayoutBase {

		private int nPoles;

		public AnalogLowPass(int _nPoles) {
			super(_nPoles);
			nPoles = _nPoles;
			setNormal(0, 1);
		}

		public void design() {
			reset();
			double n2 = 2 * nPoles;
			int pairs = nPoles / 2;
			for (int i = 0; i < pairs; ++i) {
				Complex c = ComplexUtils.polar2Complex(1F, Math.PI/2.0
						+ (2 * i + 1) * Math.PI / n2);
				addPoleZeroConjugatePairs(c, Complex.INF);
			}

			if ((nPoles & 1) == 1)
				add(new Complex(-1), Complex.INF);
		}
	}

	private void setupLowPass(int order, double sampleRate,
			double cutoffFrequency, int directFormType) {

		AnalogLowPass m_analogProto = new AnalogLowPass(order);
		m_analogProto.design();

		LayoutBase m_digitalProto = new LayoutBase(order);

		new LowPassTransform(cutoffFrequency / sampleRate, m_digitalProto,
				m_analogProto);

		setLayout(m_digitalProto, directFormType);
	}

	/**
	 * Butterworth Lowpass filter with default topology
	 * 
	 * @param order
	 *            The order of the filter
	 * @param sampleRate
	 *            The sampling rate of the system
	 * @param cutoffFrequency
	 *            the cutoff frequency
	 */
	public void lowPass(int order, double sampleRate, double cutoffFrequency) {
		setupLowPass(order, sampleRate, cutoffFrequency,
				DirectFormAbstract.DIRECT_FORM_II);
	}

}

</script>


</head>

<body>

<div id="div_g" style="width:1200px; height:600px;"></div>

<script type="text/javascript">

$(document).ready(function () {

var data = [];

var rec_flag = false;

var start_time;

var connection;

var xconnect = document.getElementById("myPuck_connect");

var savemy_CSV = document.getElementById("my_Savedata");

var rec_startstop = document.getElementById("myrecord_start");

var taxis_increment = 10 * 1000; /// axis increment in milliseconds

var t = new Date();

data.push([t, 1000.000]);

var date_win_min = t.getTime();

var date_win_max = date_win_min + 2*taxis_increment;

{

drawPoints: true,

showRoller: true,

digitsAfterDecimal: 3,

dateWindow: [date_win_min, date_win_max],

// valueRange: [980, 1020],

labels: ['Time', 'Acceleration Magnitude'],

showRangeSelector: true

});


function onLine(v) {

if(rec_flag) {

var x = new Date(); // current time

var y = parseFloat(v);

if ( x.getTime() >= date_win_max) {

date_win_min += taxis_increment;

date_win_max += taxis_increment;

g.updateOptions( { dateWindow : [date_win_min, date_win_max] } );

};

<script type="text/javascript"> 
Butterworth butterworth = new Butterworth();
butterworth.lowPass(4,0.01,10);
data = butterworth.filter(data); 
</script>

data.push([x, y]);


if ((data.length&15)==15) g.updateOptions( { 'file': data } );

};

}


function startstop_record()

{

if(rec_flag) {

rec_startstop.textContent = "Start New Recording";

rec_flag = false;

connection.write("clearInterval(1)\n", function() { });

} else {

data.splice(0,data.length);

connection.write("setInterval(function(){Bluetooth.println(resp().toFixed(3));} ,10); \n", function() { });

 t = new Date();

start_time = t;

var date_win_min = t.getTime();

var date_win_max = date_win_min + 2*taxis_increment;

g.updateOptions( { dateWindow : [date_win_min, date_win_max] } );

rec_flag = true;

rec_startstop.textContent= "Stop Recording";

};

}


function bluetooth_connect() {

Puck.connect(function(c) {

// alert("In Puck connect");

if (!c) {

alert("Couldn't connect!");

return;

}

connection = c;

// Handle the data we get back, and call 'onLine'

// whenever we get a line

var buf = "";

connection.on("data", function(d) {

buf += d;

var i = buf.indexOf("\n");

while (i>=0) {

onLine(buf.substr(0,i));

buf = buf.substr(i+1);

i = buf.indexOf("\n");

}

}); // connection.on ()

xconnect.textContent = "Disconnect Puck via Bluetooth";

}); // End Puck.connect ()

}


function savemyCSV() {

var csvContent = '';

data.forEach(function(dataArray, index) {

var diff_time = dataArray[0].getTime()-start_time;

dataString = diff_time.toFixed(0) + ',' + dataArray[1].toFixed(3);

csvContent += index < data.length ? dataString + '\n' : dataString;

});


// The download function takes a CSV string, the filename and mimeType as parameters

// Scroll/look down at the bottom of this snippet to see how download is called

var download = function(content, fileName, mimeType) {

var a = document.createElement('a');

mimeType = mimeType || 'application/octet-stream';

if (navigator.msSaveBlob) { // IE10

navigator.msSaveBlob(new Blob([content], { type: mimeType }), fileName);

} else if (URL && 'download' in a) { //html5 A[download]

a.href = URL.createObjectURL(new Blob([content], { type: mimeType }));


a.setAttribute('download', fileName);

document.body.appendChild(a);

a.click();

document.body.removeChild(a);

} else {

location.href = 'data:application/octet-stream,' + encodeURIComponent(content); // only this mime type is supported

}

}

download(csvContent, 'Puck.csv', 'text/csv;encoding:utf-8');

} // end savemyCSV();



xconnect.addEventListener("click", function () { bluetooth_connect() } );

savemy_CSV.addEventListener("click", function () { savemyCSV() } );

rec_startstop.addEventListener("click", function () { startstop_record() } );

});



</script>

</body>

</html>
